---
import { Renderer, Program, Triangle, Mesh } from "ogl";

interface Props {
  raysOrigin?: string;
  raysColor?: string;
  raysSpeed?: number;
  lightSpread?: number;
  rayLength?: number;
  pulsating?: boolean;
  fadeDistance?: number;
  saturation?: number;
  followMouse?: boolean;
  mouseInfluence?: number;
  noiseAmount?: number;
  distortion?: number;
  class?: string;
  id?: string;
}

const {
  raysOrigin = "top-center",
  raysColor = "#ffffff",
  raysSpeed = 1,
  lightSpread = 1,
  rayLength = 3,
  pulsating = false,
  fadeDistance = 1.5,
  saturation = 1.0,
  followMouse = false,
  mouseInfluence = 0.1,
  noiseAmount = 0.0,
  distortion = 0.0,
  class: className = "",
  id: passedId,
} = Astro.props;

const elId = passedId ?? `lightrays-${Math.random().toString(36).slice(2)}`;
---

<div
  id={elId}
  class={`w-full h-full pointer-events-none relative overflow-hidden ${className}`}
>
</div>

<script
  type="module"
  define:vars={{
    elId,
    raysOrigin,
    raysColor,
    raysSpeed,
    lightSpread,
    rayLength,
    pulsating,
    fadeDistance,
    saturation,
    followMouse,
    mouseInfluence,
    noiseAmount,
    distortion,
  }}
>
  (async () => {
    let Renderer, Program, Triangle, Mesh;
    try {
      ({ Renderer, Program, Triangle, Mesh } = await import("ogl"));
    } catch {
      ({ Renderer, Program, Triangle, Mesh } = await import(
        "https://esm.sh/ogl"
      ));
    }

    const hexToRgb = (hex) => {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m
        ? [
            parseInt(m[1], 16) / 255,
            parseInt(m[2], 16) / 255,
            parseInt(m[3], 16) / 255,
          ]
        : [1, 1, 1];
    };

    const getAnchorAndDir = (origin, w, h) => {
      const outside = 0.2;
      switch (origin) {
        case "top-left":
          return { anchor: [0, -outside * h], dir: [0, 1] };
        case "top-right":
          return { anchor: [w, -outside * h], dir: [0, 1] };
        case "left":
          return { anchor: [-outside * w, 0.5 * h], dir: [1, 0] };
        case "right":
          return { anchor: [(1 + outside) * w, 0.5 * h], dir: [-1, 0] };
        case "bottom-left":
          return { anchor: [0, (1 + outside) * h], dir: [0, -1] };
        case "bottom-center":
          return { anchor: [0.5 * w, (1 + outside) * h], dir: [0, -1] };
        case "bottom-right":
          return { anchor: [w, (1 + outside) * h], dir: [0, -1] };
        default:
          return { anchor: [0.5 * w, -outside * h], dir: [0, 1] };
      }
    };

    const container = document.getElementById(elId);
    if (!container) return;

    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) init();
        else cleanup();
      },
      { threshold: 0.1 },
    );
    observer.observe(container);

    let renderer, uniforms, mesh, animationId;
    let mouse = { x: 0.5, y: 0.5 };
    let smoothMouse = { x: 0.5, y: 0.5 };

    const vert = `
      attribute vec2 position;
      varying vec2 vUv;
      void main() {
        vUv = position * 0.5 + 0.5;
        gl_Position = vec4(position, 0.0, 1.0);
      }`;

    const frag = `precision highp float;
      uniform float iTime;
      uniform vec2  iResolution;
      uniform vec2  rayPos;
      uniform vec2  rayDir;
      uniform vec3  raysColor;
      uniform float raysSpeed;
      uniform float lightSpread;
      uniform float rayLength;
      uniform float pulsating;
      uniform float fadeDistance;
      uniform float saturation;
      uniform vec2  mousePos;
      uniform float mouseInfluence;
      uniform float noiseAmount;
      uniform float distortion;
      varying vec2 vUv;
      float noise(vec2 st){return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);}
      float rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord,float seedA, float seedB, float speed){
        vec2 sourceToCoord = coord - raySource;
        vec2 dirNorm = normalize(sourceToCoord);
        float cosAngle = dot(dirNorm, rayRefDirection);
        float distortedAngle = cosAngle + distortion * sin(iTime*2.0+length(sourceToCoord)*0.01)*0.2;
        float spreadFactor = pow(max(distortedAngle, 0.0), 1.0/max(lightSpread,0.001));
        float distance = length(sourceToCoord);
        float maxDistance = iResolution.x * rayLength;
        float lengthFalloff = clamp((maxDistance-distance)/maxDistance,0.0,1.0);
        float fadeFalloff = clamp((iResolution.x*fadeDistance-distance)/(iResolution.x*fadeDistance),0.5,1.0);
        float pulse = pulsating>0.5?(0.8+0.2*sin(iTime*speed*3.0)):1.0;
        float baseStrength = clamp(
          (0.45+0.15*sin(distortedAngle*seedA+iTime*speed))+
          (0.3+0.2*cos(-distortedAngle*seedB+iTime*speed)),
          0.0,1.0);
        return baseStrength*lengthFalloff*fadeFalloff*spreadFactor*pulse;
      }
      void main(){
        vec2 coord = vec2(gl_FragCoord.x, iResolution.y - gl_FragCoord.y);
        vec2 finalRayDir = rayDir;
        if(mouseInfluence>0.0){
          vec2 mouseScreenPos = mousePos * iResolution.xy;
          vec2 mouseDirection = normalize(mouseScreenPos - rayPos);
          finalRayDir = normalize(mix(rayDir, mouseDirection, mouseInfluence));
        }
        vec4 rays1 = vec4(1.0) * rayStrength(rayPos, finalRayDir, coord, 36.2214, 21.11349, 1.5*raysSpeed);
        vec4 rays2 = vec4(1.0) * rayStrength(rayPos, finalRayDir, coord, 22.3991, 18.0234, 1.1*raysSpeed);
        vec4 fragColor = rays1 * 0.5 + rays2 * 0.4;
        if(noiseAmount>0.0){
          float n=noise(coord*0.01+iTime*0.1);
          fragColor.rgb *= (1.0-noiseAmount+noiseAmount*n);
        }
        float brightness=1.0-(coord.y/iResolution.y);
        fragColor.x*=0.1+brightness*0.8;
        fragColor.y*=0.3+brightness*0.6;
        fragColor.z*=0.5+brightness*0.5;
        if(saturation!=1.0){
          float gray=dot(fragColor.rgb,vec3(0.299,0.587,0.114));
          fragColor.rgb=mix(vec3(gray),fragColor.rgb,saturation);
        }
        fragColor.rgb*=raysColor;
        gl_FragColor=fragColor;
      }`;

    const init = () => {
      if (renderer) return;
      renderer = new Renderer({
        dpr: Math.min(window.devicePixelRatio, 2),
        alpha: true,
      });
      const gl = renderer.gl;
      gl.canvas.style.width = "100%";
      gl.canvas.style.height = "100%";
      container.innerHTML = "";
      container.appendChild(gl.canvas);

      uniforms = {
        iTime: { value: 0 },
        iResolution: { value: [1, 1] },
        rayPos: { value: [0, 0] },
        rayDir: { value: [0, 1] },
        raysColor: { value: hexToRgb(raysColor) },
        raysSpeed: { value: raysSpeed },
        lightSpread: { value: lightSpread },
        rayLength: { value: rayLength },
        pulsating: { value: pulsating ? 1.0 : 0.0 },
        fadeDistance: { value: fadeDistance },
        saturation: { value: saturation },
        mousePos: { value: [0.5, 0.5] },
        mouseInfluence: { value: mouseInfluence },
        noiseAmount: { value: noiseAmount },
        distortion: { value: distortion },
      };

      const geometry = new Triangle(gl);
      const program = new Program(gl, {
        vertex: vert,
        fragment: frag,
        uniforms,
      });
      mesh = new Mesh(gl, { geometry, program });

      const updatePlacement = () => {
        renderer.dpr = Math.min(window.devicePixelRatio, 2);
        const { clientWidth: wCSS, clientHeight: hCSS } = container;
        renderer.setSize(wCSS, hCSS);
        const dpr = renderer.dpr;
        const w = wCSS * dpr,
          h = hCSS * dpr;
        uniforms.iResolution.value = [w, h];
        const { anchor, dir } = getAnchorAndDir(raysOrigin, w, h);
        uniforms.rayPos.value = anchor;
        uniforms.rayDir.value = dir;
      };

      const loop = (t) => {
        if (!renderer || !uniforms || !mesh) return;
        uniforms.iTime.value = t * 0.001;
        if (followMouse && mouseInfluence > 0.0) {
          const s = 0.92;
          smoothMouse.x = smoothMouse.x * s + mouse.x * (1 - s);
          smoothMouse.y = smoothMouse.y * s + mouse.y * (1 - s);
          uniforms.mousePos.value = [smoothMouse.x, smoothMouse.y];
        }
        renderer.render({ scene: mesh });
        animationId = requestAnimationFrame(loop);
      };

      window.addEventListener("resize", updatePlacement);
      updatePlacement();
      animationId = requestAnimationFrame(loop);

      if (followMouse) {
        window.addEventListener("mousemove", (e) => {
          const rect = container.getBoundingClientRect();
          mouse.x = (e.clientX - rect.left) / rect.width;
          mouse.y = (e.clientY - rect.top) / rect.height;
        });
      }
    };

    const cleanup = () => {
      if (animationId) cancelAnimationFrame(animationId);
      if (renderer) {
        try {
          const canvas = renderer.gl.canvas;
          const loseCtx = renderer.gl.getExtension("WEBGL_lose_context");
          if (loseCtx) loseCtx.loseContext();
          canvas?.remove();
        } catch (e) {
          console.warn("Cleanup error:", e);
        }
      }
      renderer = null;
      uniforms = null;
      mesh = null;
    };

    document.addEventListener("astro:before-swap", cleanup);
    window.addEventListener("beforeunload", cleanup);
    window.addEventListener("pagehide", cleanup);
  })();
</script>
